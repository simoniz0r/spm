#!/bin/bash
# travisci.sh script for checking AppImages for spm

# Function that uses jq to parse the json files that are generated by the updatelist function
function parsestoredinfo() {
    PACKAGE="$1"
    PACKAGE_NAME="$(jq -r '.name' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_DESCRIPTION="$(jq -r '.description' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_AUTHOR="$(jq -r '.authors[0].name' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_AUTHOR_URL="$(jq -r '.authors[0].url' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_DL_URL="$(jq -r '.links[1].url' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_API_URL="$(jq -r '.links[0].url' "$HOME"/spm/appimages/"$PACKAGE".json)"
    PACKAGE_API_URL="https://api.github.com/repos/$PACKAGE_API_URL/releases"
}

# Function that uses curl and jq to get the latest release info for package
# If user has stored their GITHUB_TOKEN in CONFIG_DIR/spm.conf, it is used to extend rate limit to 5000/hour
# The .AppImage or .AppImage extension is used in 2 of the 4 checks to make sure we only install packages
# The package name is used in 2 of the 4 checks to try and make sure the correct package is always found
# We also try to find only 64bit packages by making sure the package name does not contain 32bit related things
# Each check gets less specific until we hopefully find an package on the Github release page
# If no package is found, an error is outputted to the user
# We also get some useful info for the users here such as the package size and number of installs
function githubrelease () {
    PACKAGE="$1"
    if [ -z "$GITHUB_TOKEN" ]; then
        curl -sSL -o "$HOME"/cache/"$PACKAGE"full "$PACKAGE_API_URL" || { spmexit "3" "$(tput setaf $CLR_RED)Error$(tput sgr0)" "curl $PACKAGE_API_URL failed!"; }
    else
        curl -sSL -o "$HOME"/cache/"$PACKAGE"full -H "Authorization: token "$GITHUB_TOKEN"" "$PACKAGE_API_URL" || { spmexit "3" "$(tput setaf $CLR_RED)Error$(tput sgr0)" "curl failed!"; }
    fi
    cd "$HOME"/cache
    JQARG=".[].assets[] | select(.name | contains(\".AppImage\"), contains(\".appimage\")) | select(.name | contains(\"$PACKAGE_NAME\")) | select(.name | contains(\".zsync\") | not) | select(.name | contains(\"ia32\") | not) | select(.name | contains(\"i386\") | not) | select(.name | contains(\"i686\") | not) | { name: .name, updated: .updated_at, url: .browser_download_url, size: .size, numdls: .download_count}"
    cat "$HOME"/cache/"$PACKAGE"full | jq --raw-output "$JQARG" | csplit --digits=2 --quiet --prefix="$PACKAGE" --suffix-format=%02d.json - "/^{/" "{*}"
    if [ ! -f "$HOME/cache/${PACKAGE}01.json" ]; then
        rm -f "$HOME"/cache/"$PACKAGE"00.json
        JQARG=".[].assets[] | select(.name | contains(\".AppImage\"), contains(\".appimage\")) | select(.name | contains(\".zsync\") | not) | select(.name | contains(\"ia32\") | not) | select(.name | contains(\"i386\") | not) | select(.name | contains(\"i686\") | not) | { name: .name, updated: .updated_at, url: .browser_download_url, size: .size, numdls: .download_count}"
        cat "$HOME"/cache/"$PACKAGE"full | jq --raw-output "$JQARG" | csplit --digits=2 --quiet --prefix="$PACKAGE" --suffix-format=%02d.json - "/^{/" "{*}"
    fi
    if [ ! -f "$HOME/cache/${PACKAGE}01.json" ]; then
        rm -f "$HOME"/cache/"$PACKAGE"00.json
        JQARG=".[].assets[] | select(.name | contains(\"$PACKAGE_NAME\")) | select(.name | contains(\".zsync\") | not) | select(.name | contains(\"ia32\") | not) | select(.name | contains(\"i386\") | not) | select(.name | contains(\"i686\") | not) | { name: .name, updated: .updated_at, url: .browser_download_url, size: .size, numdls: .download_count}"
        cat "$HOME"/cache/"$PACKAGE"full | jq --raw-output "$JQARG" | csplit --digits=2 --quiet --prefix="$PACKAGE" --suffix-format=%02d.json - "/^{/" "{*}"
    fi
    if [ ! -f "$HOME/cache/${PACKAGE}01.json" ]; then
        rm -f "$HOME"/cache/"$PACKAGE"00.json
        JQARG=".[].assets[] | select(.name | contains(\".zsync\") | not) | select(.name | contains(\"ia32\") | not) | select(.name | contains(\"i386\") | not) | select(.name | contains(\"i686\") | not) | { name: .name, updated: .updated_at, url: .browser_download_url, size: .size, numdls: .download_count}"
        cat "$HOME"/cache/"$PACKAGE"full | jq --raw-output "$JQARG" | csplit --digits=2 --quiet --prefix="$PACKAGE" --suffix-format=%02d.json - "/^{/" "{*}"
    fi
    if [ -f "$HOME/cache/${PACKAGE}01.json" ]; then
        PACKAGE_NAME="$(jq -r '.name' "$HOME"/cache/"$PACKAGE"01.json)"
        NEW_PACKAGE_VERSION="$(jq -r '.updated' "$HOME"/cache/"$PACKAGE"01.json)"
        PACKAGE_LATEST_URL="$(jq -r '.url' "$HOME"/cache/"$PACKAGE"01.json)"
        PACKAGE_SIZE="$(jq -r '.size' "$HOME"/cache/"$PACKAGE"01.json)"
        PACKAGE_SIZE="$(awk "BEGIN {print ("$PACKAGE_SIZE"/1024)/1024}" | cut -c-5) MBs"
        PACKAGE_DOWNLOADS="$(jq -r '.numdls' "$HOME"/cache/"$PACKAGE"01.json)"
        PACKAGE_TAG="$(echo "$PACKAGE_LATEST_URL" | cut -f8 -d"/")"
    else
        PACKAGE_NAME="Error finding $PACKAGE!"
        NEW_PACKAGE_VERSION="Error finding $PACKAGE!"
        PACKAGE_LATEST_URL="Error finding $PACKAGE!"
        PACKAGE_SIZE="Error finding $PACKAGE!"
        PACKAGE_DOWNLOADS="Error finding $PACKAGE!"
        PACKAGE_TAG="Error finding $PACKAGE!"
    fi
}

# incomplete for loop for testing purposes
for appimage in "$(dir -C -w 1 $HOME/spm/appimages | head -n 30)"; do
    RELEASE_TYPE="$(jq -r '.links[0].type' $HOME/spm/appimages/$appimage)"
    case "$RELEASE_TYPE" in
        GitHub)
            PACKAGE_NAME="$(jq -r '.name' $HOME/spm/appimages/$appimage)"
            parsestoredinfo "$PACKAGE_NAME"
            githubrelease "$PACKAGE_NAME"
            if [ -z "$NEW_PACKAGE_VERSION" ]; then
                echo "$(tput setaf $CLR_RED)Error checking version for $PACKAGE$(tput setaf $CLR_RED); skipping...$(tput sgr0)"
            elif [ "$NEW_PACKAGE_VERSION" != "$PACKAGE_VERSION" ]; then
                # echo "$(tput setaf $CLR_CYAN)New update for $PACKAGE$(tput setaf $CLR_CYAN)! Version: $PACKAGE_TAG Release date: $NEW_PACKAGE_VERSION$(tput sgr0)"
                # echo "PACKAGE_LATEST_URL="\"$PACKAGE_LATEST_URL\""" > "$HOME"/upgrades/"$PACKAGE"
                # echo "PACKAGE_TAG="\"$PACKAGE_TAG\""" >> "$HOME"/upgrades/"$PACKAGE"
                # echo "NEW_PACKAGE_VERSION="\"$NEW_PACKAGE_VERSION\""" >> "$HOME"/upgrades/"$PACKAGE"
            fi
        *)
            echo "$RELEASE_TYPE not yet finished"
            ;;
    esac
done
exit 0
